{"ast":null,"code":"import React from\"react\";import{connect}from\"react-redux\";import{ReactComponent as ShoppingIcon}from\"@svgr/webpack?-svgo,+titleProp,+ref!../../assets/shopping-bag.svg\";import{toggleCartHidden as _toggleCartHidden}from\"../../redux/cart/cart-actions.js\";import{selectCartItemsCount}from\"../../redux/cart/cart-selectors.js\";import\"./cart-icon.scss\";var CartIcon=function CartIcon(_ref){var toggleCartHidden=_ref.toggleCartHidden,itemCount=_ref.itemCount;return/*#__PURE__*/React.createElement(\"div\",{className:\"cart-icon\",onClick:toggleCartHidden},/*#__PURE__*/React.createElement(ShoppingIcon,{className:\"shopping-icon\"}),/*#__PURE__*/React.createElement(\"span\",{className:\"item-count\"},\" \",itemCount,\" \"));};var mapDispatchToProps=function mapDispatchToProps(dispatch){return{toggleCartHidden:function toggleCartHidden(){return dispatch(_toggleCartHidden());}};};// this method means we are listening to any changes that made to the store.\nvar mapStateToProps=function mapStateToProps(state){return{itemCount:selectCartItemsCount(state)};};export default connect(mapStateToProps,mapDispatchToProps)(CartIcon);/*\r\nTo understand this we need to start from reducer\r\n\r\n\r\n\r\nPrerequisite understanding:\r\n\r\n1. if reducer return new value (new object), then this mean state change\r\n2. when state change, store will run every mounted component's mapStateToProps\r\n\r\nIt will rerender every mapStateToProps\r\n\r\n\r\nI hope this is clear at this point, because it is crucial to explain why memoization is needed\r\n\r\nimagine component A has some expensive calculation in its mapStateToProps\r\n\r\nconst mapState = (state) => {\r\n     return {profit: expensiveCalculation(state.num1,state.num2,state.num3)};\r\n}\r\n\r\n\r\nnow recall what I mentioned earlier: any state change will run all mapStateToProps!\r\n\r\n\r\nImagine component B dispatch an action that return new state from reducer, eventhough this state change has nothing to do with component A, store will still use the same state to run component A's mapStateToProps, thus the expensiveCalculation run every single time for no obvious reason!\r\n\r\n\r\n\r\nTo prevent this, reselect library help us with memoization\r\n\r\nconst mapState = (state) => {\r\n     return {profit: selectProfit(state)};\r\n}\r\nwhen mapStateToProps is called again due to any state update of any other components, Reselect will not run expensive calculation if the input values state.num1, state.num2, state.num3 remain the same with previous run.\r\n\r\n\r\nWith reselect we are memoizing the value of each selector that calls createSelector, as long as the value parameters passed in haven't changed, then our selector won't re-compute and just returned the previously memoized value.\r\n*/","map":{"version":3,"sources":["C:/Users/prash/Desktop/React/ecom-clothing/src/components/cart-icon/cart-icon.jsx"],"names":["React","connect","toggleCartHidden","selectCartItemsCount","CartIcon","itemCount","mapDispatchToProps","dispatch","mapStateToProps","state"],"mappings":"AAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,OAAT,KAAwB,aAAxB,C,8GAIA,OAASC,gBAAgB,GAAhBA,CAAAA,iBAAT,KAAiC,kCAAjC,CACA,OAASC,oBAAT,KAAqC,oCAArC,CAEA,MAAO,kBAAP,CAEA,GAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,UAAGF,CAAAA,gBAAH,MAAGA,gBAAH,CAAqBG,SAArB,MAAqBA,SAArB,oBACf,2BAAK,SAAS,CAAC,WAAf,CAA2B,OAAO,CAAEH,gBAApC,eACE,oBAAC,YAAD,EAAc,SAAS,CAAC,eAAxB,EADF,cAEE,4BAAM,SAAS,CAAC,YAAhB,MAA+BG,SAA/B,KAFF,CADe,EAAjB,CAOA,GAAMC,CAAAA,kBAAkB,CAAG,QAArBA,CAAAA,kBAAqB,CAACC,QAAD,QAAe,CACxCL,gBAAgB,CAAE,kCAAMK,CAAAA,QAAQ,CAACL,iBAAgB,EAAjB,CAAd,EADsB,CAAf,EAA3B,CAIA;AACA,GAAMM,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACC,KAAD,QAAY,CAClCJ,SAAS,CAAEF,oBAAoB,CAACM,KAAD,CADG,CAAZ,EAAxB,CAIA,cAAeR,CAAAA,OAAO,CAACO,eAAD,CAAkBF,kBAAlB,CAAP,CAA6CF,QAA7C,CAAf,CAEA","sourcesContent":["import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\n\r\nimport { ReactComponent as ShoppingIcon } from \"../../assets/shopping-bag.svg\";\r\n\r\nimport { toggleCartHidden } from \"../../redux/cart/cart-actions.js\";\r\nimport { selectCartItemsCount } from \"../../redux/cart/cart-selectors.js\";\r\n\r\nimport \"./cart-icon.scss\";\r\n\r\nconst CartIcon = ({ toggleCartHidden, itemCount }) => (\r\n  <div className=\"cart-icon\" onClick={toggleCartHidden}>\r\n    <ShoppingIcon className=\"shopping-icon\" />\r\n    <span className=\"item-count\"> {itemCount} </span>\r\n  </div>\r\n);\r\n\r\nconst mapDispatchToProps = (dispatch) => ({\r\n  toggleCartHidden: () => dispatch(toggleCartHidden()),\r\n});\r\n\r\n// this method means we are listening to any changes that made to the store.\r\nconst mapStateToProps = (state) => ({\r\n  itemCount: selectCartItemsCount(state),\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(CartIcon);\r\n\r\n/*\r\nTo understand this we need to start from reducer\r\n\r\n\r\n\r\nPrerequisite understanding:\r\n\r\n1. if reducer return new value (new object), then this mean state change\r\n2. when state change, store will run every mounted component's mapStateToProps\r\n\r\nIt will rerender every mapStateToProps\r\n\r\n\r\nI hope this is clear at this point, because it is crucial to explain why memoization is needed\r\n\r\nimagine component A has some expensive calculation in its mapStateToProps\r\n\r\nconst mapState = (state) => {\r\n     return {profit: expensiveCalculation(state.num1,state.num2,state.num3)};\r\n}\r\n\r\n\r\nnow recall what I mentioned earlier: any state change will run all mapStateToProps!\r\n\r\n\r\nImagine component B dispatch an action that return new state from reducer, eventhough this state change has nothing to do with component A, store will still use the same state to run component A's mapStateToProps, thus the expensiveCalculation run every single time for no obvious reason!\r\n\r\n\r\n\r\nTo prevent this, reselect library help us with memoization\r\n\r\nconst mapState = (state) => {\r\n     return {profit: selectProfit(state)};\r\n}\r\nwhen mapStateToProps is called again due to any state update of any other components, Reselect will not run expensive calculation if the input values state.num1, state.num2, state.num3 remain the same with previous run.\r\n\r\n\r\nWith reselect we are memoizing the value of each selector that calls createSelector, as long as the value parameters passed in haven't changed, then our selector won't re-compute and just returned the previously memoized value.\r\n*/\r\n"]},"metadata":{},"sourceType":"module"}